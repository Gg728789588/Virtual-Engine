#include "Include/Sampler.cginc"
cbuffer CullBuffer : register(b0)
{
    float4 planes[6];
    //Align
    float4 _FrustumMinPoint;
    float4 _FrustumMaxPoint;
    uint _Count;
};
struct MultiDrawCommand
{
    uint IndexCountPerInstance;
    uint InstanceCount;
    uint StartIndexLocation;
    int BaseVertexLocation;
    uint StartInstanceLocation;
};
struct ObjectData
{
    float4x4 localToWorld;			//64
    uint _align[48];    //(256 - 64) / 4
};
StructuredBuffer<ObjectData> _InputDataBuffer : register(t0);
RWStructuredBuffer<MultiDrawCommand> _OutputBuffer : register(u0);
RWStructuredBuffer<ObjectData> _OutputDataBuffer : register(u1);



float PlaneTest(float4x4 localToWorld){
    const float3 localPosition = 0;
    const float3 extent = 0.5;
    float3 position = mul(localToWorld, float4(localPosition, 1)).xyz;
    float3 worldMin = position;
    float3 worldMax = position;
    uint i;
    
    const float3 offsetRate[8] = {
        float3(1, 1, 1),
        float3(1, 1, -1),
        float3(1, -1, 1),
        float3(1, -1, -1),
        float3(-1, 1, 1),
        float3(-1, 1, -1),
        float3(-1, -1, 1),
        float3(-1, -1, -1)
    };
    
    [loop]
    for(i = 0; i < 8; ++i)
    {
        float3 currPos = mul(localToWorld, float4(localPosition + extent * offsetRate[i], 1)).xyz;
        worldMin = min(worldMin, currPos);
        worldMax = max(worldMax, currPos);
    }
    float outOfRange = dot(_FrustumMinPoint.xyz > worldMax, 1) + dot(_FrustumMaxPoint.xyz < worldMin, 1);
    if(outOfRange > 0.5) return 0;
    [loop]
    for(i = 0; i < 6; ++i)
    {
        float4 plane = planes[i];
        float3 absNormal = abs(mul(plane.xyz, (float3x3)localToWorld));
        if((dot(position, plane.xyz) - dot(absNormal, extent)) > -plane.w)
        {
            return 0;
        }
    }
    return 1;
}

[numthreads(64, 1, 1)]
void CSMain(uint id : SV_DISPATCHTHREADID)
{
    if(id >= _Count) return;
    uint count;
    ObjectData data = _InputDataBuffer[id];
    if(PlaneTest(data.localToWorld) > 0.5)
    {
        InterlockedAdd(_OutputBuffer[0].InstanceCount, 1, count);
        _OutputDataBuffer[count] = data;
    }
}

[numthreads(1,1,1)]
void Clear()
{
    MultiDrawCommand clearedValue = (MultiDrawCommand)0;
    clearedValue.IndexCountPerInstance = 36;    //Cube Should have 36 vertex
    _OutputBuffer[0] = clearedValue;
}
